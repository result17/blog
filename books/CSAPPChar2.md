## 无符号编码
基于传统的二进制表示大于或者等于零的数字。
## 补码编码
补码编码是表示有符号整数的最常见方式。
## 浮点数编码
表示实数的科学记数法的以2为基数的版本。
## 内存单位
大多数计算机使用8位的块，或者字节，作为最小的可寻址内存单位。
## 虚拟内存
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址。所有可能地址的集合就称为虚拟地址空间，
## 练习题2.1
A. 0x39A7F8
3    9     A     7     F     8
0011 1001  1010  0111  1111  1000

B. 1100 1001 0111 1011
   C    9    7    B

C. 0xD5E4C
D    5    E    4    C
1101 0101 1110 0100 1100

D.
10 0110 1110 0111 1011 0101
2  6    E    7    B    5
## 练习题2.2
545288  0x80000
14      0x4000
16      65536
131072  0x20000
5       0x20
7       128
## 练习题2.3
0b10100111  0xA7
0b111110    0x3E
ob10111100  0xBC
55          0x37
136         0x88
0b11110011  0xF3
82          0b01010010
172         0b10101100
231         0b11100111
## 练习题2.4
0x5044
0x4FFC
0x50A0
0x00AE
## 字数据大小
每台计算机都有一个字长，指明指针数据的标称大小。字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就说，对于一个字长为w位的机器而言，虚拟地址的范围为0 - 2**w - 1，程序最多访问2w个字节。
大多数64机器也可以运行32位机器编译的程序，是向后兼容的。
所以我们将程序称为“32位程序”或“64位程序”，区别在于该程序是如何编译。
## 大端法和小端法（字节序）
某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象位小端法。而另一种机器按照从最高有效字节到最低有效字节的顺序存储，称为大端法。
假设变量X的类型位int，位于地址0x100处，它的十六进制为0x01234567。
![img](https://github.com/result17/blog/blob/master/imgs/endian.png?raw=true)
Intel都只用小端法，而IBM则采用大端法。比较新的处理器用的双端法。而Android和IOS只能用小端法。
大端法的好处是最先取最高位，能快速判断数值是正数还是负数。
小段法的好处是最先取最低位，方便进行位运算。
字节序只跟多字节的整型数据类型有关，比如int、short、long型，跟单字节的byte无关。
## sizeof运算符
c语言的运算符sizeof来确定对象使用的字节数。
## typedef来命名数据类型
c语言中的typedef生命提供了一种给数据类型命名的方式。 
```c
typedef int *int_pointer;
int_pointer ip;
```
将类型“int_pointer"定义为一个指向int的指针，并且生命了一个这中类型的变量ip。
## printf格式化输出
printf函数提供了一种打印信息的方式。第一个参数是格式串，而其余的参数都是要打印的值。
'%d'是输出一个十进制整数，'%f'是输出一个浮点数，而‘%c'是输出一个字符，其编码由参数给出。
## C和C++特有的“取地址”运算符
表达式&x创建一个指向保存变量x的位置指针。
## 练习题2.5
首先得理解在16进制中两位表示一个字节
A 21             87
B 21 43          87 65
C 21 43 65       87 65 43
## 练习题2.6
A  0000 0000 0011 0101 1001 0001 0100 0001
   0100 1010 0101 0110 0100 0101 0000 0100
B 将第二个字相对于第一个字向右移动2位，我们发现一个有21给匹配位的序列。
C  我们发现除了最高有效位1，整数的所有位都嵌在浮点数中。另外，浮点数有一些非零的高位不与整数中的高位匹配。
## 表示字符串
C语言中字符串被编码为null（值为0）字符结尾的字符数组。（此数组长度等于字符长度加上一个终止位）。在使用ascii码作为字符码的任何系统上都将得到相同结果（由低地址到高地址，以00结尾），与字节顺序和字大小规则无关。因而文本数据比二进制数据具有更强的平台独立性。
## 二进制代码是不兼容的
不同的机器类型使用不同的且不兼容的指令和编码方式。即便完全一样的进程，运行在不同的操作系统上也会有不同的编码规则。
## 练习题2.8
~a [10010110]
~b [10101010]
a&b [0100001]
a|b [01111101]
^(异或 当p=1且q=0或者p=0且q=1时，p^q=1) [00111100]
## 位向量表示集合
如 位向量 a = [01101001], 集合第一位是在向量的最右边为1，所以A集合中有0。第四位有1，所以集合中有3。类推
A = {0， 3， 5， 6}
## 位运算符 ~ ^ $ |
## 练习题2.9
A 111 011
  110 010
  101 001
  100 000
B 011
  010
  001
## 练习题2.10
a                               a^b
a^a^b = (a^a)^b = b             a^b
b                               b^a^b = (b^b)^a = b
## 练习题2.11
A 都为a[k]
B 因为a[k] ^ a[k] = 0
C first < last
## 掩码和~0
x&0xFf生成一个由x的最低有效字节组成的值，而其他的字节就被制位0.
~0将生成一个全1的掩码，不管机器的字大小是多少。
## 练习题2.12
A x&0xFF
B x^~0xFF
c x|0xFF
~0xFF创建一个掩码，可以不依赖字长（比0xFFFFFF00更好）
## 练习题2.13
因为x和y都有相同位数，（不足以0补齐）bic(x, m)等价于x&~m，为了实现|运算
x ^ y = (x&~y)|(~x&y)
bis(x, y)
bis(bic(x, y), bic(y, x)) 
## 逻辑运算符|| && 和!
逻辑运算符是不同于位运算符的。按位运算只有在参数被限制0或者1，才能与对应的逻辑运算有相同行为。
## 练习题2.14
&运算符只有都为1时，才会得1，否则得0
0x20     0x01
0x7F     0x01
0xDF     0x00
0x00     0x01
## 练习题2.15
见csappCode中的isEqual.c
!用来判定一个字是否包含任何非零位。
## 移位运算
左移<< 右移>>
移位运算是从左至右可结合的。
逻辑右移在左端补k个0。
算术右移是在左端补k个最高有效位的值。就是在左端重复k个最高位的值。
对于有符号数来说，几乎所有编译器都对有符号数使用算术右移。而对无符号数，必须逻辑右移。
与C相比，Java（JS也是）对如何进行右移有明确的定义。表达是x>>k会将x算术右移k个位置，而x>>>k会对x逻辑右移。
## 移位运算的位移量
假设数据有w位，移位参数为k，则位移量为 k mod w。
换句话说，数据有32位，位移量为0。
## 练习题2.16
0b11000011  0b00011000 0x18   0b00110000 0x30  0b11110000 0xF0
0b01110101  0b10101000 0xC8   0b00011101 0x1D  0b00011101 0x1D
0b10000111  0b00111000 0x38   0b00100001 0x21  0b00100001 0x21
0b01100110  0b00110000 0x30   0b00011001 0x19  0b00011001 0x19
## C和C++都支持有符号（默认）和无符号数。Java只支持有符号数。
## 无符号数编码的定义
![img](https://github.com/result17/blog/blob/master/imgs/unsigned.png?raw=true)
## 双射
双射是指一个函数f有两面。可以由自变量得出变量，变量不能得到自变量。（双射，对称加密。单射，非对称加密）
## 补码(twos' Complement)
将字的最高有效位解释为负权-2**(w - 1)。也即是符号位.
![img](https://github.com/result17/blog/blob/master/imgs/negative.png?raw=true)
## 练习题2.17
[0000]   0     0
[0101]   5     5
[1000]   8     -8
[1011]   13    -3
[1111]   15    -1
## 有符号数的其他表示方法
C语言标准并没有要求要用补码形式来表示有符号数。有符号数还有两种标识方法：
- 反码(Ones' Complemwnr)
- 原码(sign-Magnitudse)
他们都有两个奇怪的属性，那就是杜宇数字0有两种不同的编码方式
## 练习题2.18
对于32位的机器，由8个十六进制数字组成，且最开始的那个位置在8~f之间的任何值，都是一个负数。数字以串f开头是很普遍的事情，因为负数的起始位全为1。
736
-88
40
-48
120
136
504
192
-72
## 有符号数和无符号数之间的转换
对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间的规则是：数值可能会改变，但位模式不变。
## 练习题2.19
负权 负权
-8  1000  8
-3  1101  D
-2  1110  E
-1  1111  F
0   0000  0
5   0101  5
## 有符号数（补码）转为无符号数函数
![img](https://github.com/result17/blog/blob/master/imgs/U2T.png?raw=true)
## 无符号数转转为有符号数（补码）
![img](https://github.com/result17/blog/blob/master/imgs/T2U.png?raw=true)
![img](https://github.com/result17/blog/blob/master/imgs/T2Uu2T.png?raw=true)
## 有符号和无符号数运算
当执行一个运算时，如果一个运算数是有符号的而另一个是无符号的，c语言会隐式地将有符号数强制切换位无符号数。并假设这两个数都是非负，进行运算。但对于<和>有不符合直觉的结果。
## 练习题2.21
Tmin32是-2147483648，将它强制类型转换为无符号数后，变成了2147483648.
无符号  1
有符号  1
无符号  0
有符号  1
无符号  1
## 零扩展
简单地在表示的开头添加0，这种运算被称为零扩展。（逻辑右移）
## 符号扩展
在表示中添加最高有效位的值。（算术右移）数学归纳法证明
## 练习题2.22.
A -2** (4-1) + 2** 1  +  2** 0
B -2** (5-1) + 2** 4 + 2** 1 + 2** 0
C -2** (6 - 1) + 2** 4 + 2** 5 + 2** 1 + 2** 0
## 转换类型规则
如short转unsigned(无符号整型int)，我们先要改变大小，之后再完成从有符号到无符号的转换。此规则是C语言标准要求。
## 练习题2.23
对无符号数是逻辑右移，对有符号数是算术右移 最高有效位8-F代表，第一个二进制数字位1（符号位），在算术右移时添加的是符号位。
0x00000076  0x00000076
0x00000021  0x00000021
0x000000C9  0xFFFFFFC9
0x00000087  0xFFFFFF87
## 截断数字
![img](https://github.com/result17/blog/blob/master/imgs/truncated.png?raw=true)
补码截断的公式是根据无符号数截断的推导而来。
## 练习题2.24
0        0
2        2
1        1
3        3
7        -1
截断后，字长为3。2** k = 2** 3。
补码截断可以从无符号截断结果，再B2T()，但要记得新字长为截断后的字长。
## 练习题2.25
因为参数length是无符号的，计算0-1将使用无符号晕眩，这等价于模数加法。结果得到UMax。小于等于比较同样使用无符号数比较，而因为任何数都是小于或等于Umax的，所以这个比较宗伟真。因此代码将试图访问数字a的非法元素。
可以把循环条件改为i < length。
## 练习题2.26
当s < t时， s - t会得到负数，又因为strlen()是unsigned int，此时s - t会被当做一个很大的实数。
(int)(strlen(s) - strlen(t)) > 0
或者
return strlen(s) > strlen(t)
## 避免隐式转换
一个简单粗暴的方法是绝不使用无符号数，并且要求以补码运算来实现。
## 无符号数加法
![img](https://github.com/result17/blog/blob/master/imgs/uAdd.png?raw=true)
## 检查无符号数加法溢出
![img](https://github.com/result17/blog/blob/master/imgs/uAddOverFlow.png?raw=true)
## 无符号数求反
![img](https://github.com/result17/blog/blob/master/imgs/uAddOk.png?raw=true)
## 练习题2.28
0    0     0
5    11    B
8    8     8
13   3     3
15   1     1
## 补码加法
![img](https://github.com/result17/blog/blob/master/imgs/tAdd.png?raw=true)
## 阿贝尔群
转载于
https://www.zhihu.com/question/20107927/answer/73830322
abel群是交换群，就是满足运算交换律的群。所有循环群都是abel群。
设G为一个非空集合，• 是一个自定义的运算符号.群是一个二元运算的代数结构，是近世代数的概念，
它满足封闭性（存在a，b属于G，a•b也属于G；）
结合性（存在a，b，c属于G，有a•（b•c）=（a•b）•c；）
有单位元（存在单位元e属于G，对于任意g属于G，有e•g=g•e=g；）
有逆元（对于任意g属于G，存在逆元g′，使得g•g′=g′•g=e；）

## 检查补码加法中的溢出
![img](https://github.com/result17/blog/blob/master/imgs/tAddOverFlow.png?raw=true)
## 练习题2.29
100101    00101    1
110000    10000    2
111111    11111    2
000111    00111    3
010000    10000    4

x + y要算术右移一位，再进行截断。
## 练习题2.30
查阅csappCode中的tadd_ok.c，在这里给出作者更好的实现。
```c
int tadd_ok(int x, int y) {
  int sum = x + y;
  int neg_over = x < 0 && y < 0 && sum >= 0;
  int pos_over = x >= 0 && y >= 0 && sum < 0;
  return !neg_over && !pos_over;
}
```
正常返回1，不正常返回0。
## 练习题2.31
根据阿贝尔群的定义，补码加法会形成一个阿贝尔群，因此表达式(x + y) - x求值得到y，无论加法是否溢出，而(x+y)-y总是会求值得到x。
## 练习题2.32
错误处在
如y = Tmin = 0x80000000, -y也等于0x80000000。（在int中有两个数的相反数也是自身）
因此函数tadd_ok会认为只要x是负数时，就会溢出。而x为非负数是，不会溢出。实际上，情况相反，当x为负数时，tsub_ok(x, Tmin)为1（正常），而当x为非负时，它为0。