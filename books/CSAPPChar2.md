## 无符号编码
基于传统的二进制表示大于或者等于零的数字。
## 补码编码
补码编码是表示有符号整数的最常见方式。
## 浮点数编码
表示实数的科学记数法的以2为基数的版本。
## 内存单位
大多数计算机使用8位的块，或者字节，作为最小的可寻址内存单位。
## 虚拟内存
机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字来标识，称为它的地址。所有可能地址的集合就称为虚拟地址空间，
## 练习题2.1
A. 0x39A7F8
3    9     A     7     F     8
0011 1001  1010  0111  1111  1000

B. 1100 1001 0111 1011
   C    9    7    B

C. 0xD5E4C
D    5    E    4    C
1101 0101 1110 0100 1100

D.
10 0110 1110 0111 1011 0101
2  6    E    7    B    5
## 练习题2.2
545288  0x80000
14      0x4000
16      65536
131072  0x20000
5       0x20
7       128
## 练习题2.3
0b10100111  0xA7
0b111110    0x3E
ob10111100  0xBC
55          0x37
136         0x88
0b11110011  0xF3
82          0b01010010
172         0b10101100
231         0b11100111
## 练习题2.4
0x5044
0x4FFC
0x50A0
0x00AE
## 字数据大小
每台计算机都有一个字长，指明指针数据的标称大小。字长决定的最重要的系统参数就是虚拟地址空间的最大大小。也就说，对于一个字长为w位的机器而言，虚拟地址的范围为0 - 2**w - 1，程序最多访问2w个字节。
大多数64机器也可以运行32位机器编译的程序，是向后兼容的。
所以我们将程序称为“32位程序”或“64位程序”，区别在于该程序是如何编译。
## 大端法和小端法（字节序）
某些机器选择在内存中按照从最低有效字节到最高有效字节的顺序存储对象位小端法。而另一种机器按照从最高有效字节到最低有效字节的顺序存储，称为大端法。
假设变量X的类型位int，位于地址0x100处，它的十六进制为0x01234567。
![img](https://github.com/result17/blog/blob/master/imgs/endian.png?raw=true)
Intel都只用小端法，而IBM则采用大端法。比较新的处理器用的双端法。而Android和IOS只能用小端法。
大端法的好处是最先取最高位，能快速判断数值是正数还是负数。
小段法的好处是最先取最低位，方便进行位运算。
字节序只跟多字节的整型数据类型有关，比如int、short、long型，跟单字节的byte无关。
## sizeof运算符
c语言的运算符sizeof来确定对象使用的字节数。
## typedef来命名数据类型
c语言中的typedef生命提供了一种给数据类型命名的方式。 
```c
typedef int *int_pointer;
int_pointer ip;
```
将类型“int_pointer"定义为一个指向int的指针，并且生命了一个这中类型的变量ip。
## printf格式化输出
printf函数提供了一种打印信息的方式。第一个参数是格式串，而其余的参数都是要打印的值。
'%d'是输出一个十进制整数，'%f'是输出一个浮点数，而‘%c'是输出一个字符，其编码由参数给出。
## C和C++特有的“取地址”运算符
表达式&x创建一个指向保存变量x的位置指针。
## 练习题2.5
首先得理解在16进制中两位表示一个字节
A 21             87
B 21 43          87 65
C 21 43 65       87 65 43
## 练习题2.6
A  0000 0000 0011 0101 1001 0001 0100 0001
   0100 1010 0101 0110 0100 0101 0000 0100
B 将第二个字相对于第一个字向右移动2位，我们发现一个有21给匹配位的序列。
C  我们发现除了最高有效位1，整数的所有位都嵌在浮点数中。另外，浮点数有一些非零的高位不与整数中的高位匹配。
## 表示字符串
C语言中字符串被编码为null（值为0）字符结尾的字符数组。（此数组长度等于字符长度加上一个终止位）。在使用ascii码作为字符码的任何系统上都将得到相同结果（由低地址到高地址，以00结尾），与字节顺序和字大小规则无关。因而文本数据比二进制数据具有更强的平台独立性。
## 二进制代码是不兼容的
不同的机器类型使用不同的且不兼容的指令和编码方式。即便完全一样的进程，运行在不同的操作系统上也会有不同的编码规则。
## 练习题2.8
~a [10010110]
~b [10101010]
a&b [0100001]
a|b [01111101]
^(异或 当p=1且q=0或者p=0且q=1时，p^q=1) [00111100]
## 位向量表示集合
如 位向量 a = [01101001], 集合第一位是在向量的最右边为1，所以A集合中有0。第四位有1，所以集合中有3。类推
A = {0， 3， 5， 6}
## 位运算符 ~ ^ $ |
## 练习题2.9
A 111 011
  110 010
  101 001
  100 000
B 011
  010
  001
## 练习题2.10
a                               a^b
a^a^b = (a^a)^b = b             a^b
b                               b^a^b = (b^b)^a = b
## 练习题2.11
A 都为a[k]
B 因为a[k] ^ a[k] = 0
C first < last
## 掩码和~0
x&0xFf生成一个由x的最低有效字节组成的值，而其他的字节就被制位0.
~0将生成一个全1的掩码，不管机器的字大小是多少。
## 练习题2.12
A x&0xFF
B x^~0xFF
c x|0xFF
~0xFF创建一个掩码，可以不依赖字长（比0xFFFFFF00更好）
## 练习题2.13
因为x和y都有相同位数，（不足以0补齐）bic(x, m)等价于x&~m，为了实现|运算
x ^ y = (x&~y)|(~x&y)
bis(x, y)
bis(bic(x, y), bic(y, x)) 
## 逻辑运算符|| && 和!
逻辑运算符是不同于位运算符的。按位运算只有在参数被限制0或者1，才能与对应的逻辑运算有相同行为。
## 练习题2.14
&运算符只有都为1时，才会得1，否则得0
0x20     0x01
0x7F     0x01
0xDF     0x00
0x00     0x01
## 练习题2.15
见csappCode中的isEqual.c
!用来判定一个字是否包含任何非零位。
## 移位运算
左移<< 右移>>
移位运算是从左至右可结合的。
逻辑右移在左端补k个0。算术右移是在左端补k个最高有效位的值。就是在左端重复k个最高位的值。
对于有符号数来说，几乎所有编译器都对有符号数使用算术右移。而对无符号数，必须逻辑右移。
与C相比，Java（JS也是）对如何进行右移有明确的定义。表达是x>>k会将x算术右移k个位置，而x>>>k会对x逻辑右移。