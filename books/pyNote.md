## 实例对象ID
存货的实例对象都有个“唯一”的ID
```python
id(123)
474561464
id("abc")
414631436
```
CPython(python的官方实现，最多库支持和流行的版本)用内存地址作为ID值。这意味着它只能保证在某个时间，在所有存活对象是唯一的，不保证整个进程生命周期内是唯一的，因为内存地址会被复用（GC）。如此，ID也就不适合作为全局身份识别。
## 多继承
Python支持多继承，就是一个subType有多个superType。
## 祖先类型
所有类型都有一个共同祖先类型object。
## 所有类型都是type实例
```python
isinstance(int, type)
true
```
## 名字
在python这类动态语言里，名字和对象是两个实体。名字不但有自己的类型，要分配内存，还会介入实际执行过程。名字是python动态执行模型的基础。
## python是动态类型语言的原因
在运行时才能知道名字引用的目标类型
## 命名空间
对Python来说，每个模块都有一个全局命名空间(globals)。根据代码作用域，又有当前命名空间(locals)。但在某个函数内，当前命名空间专指函数执行栈帧(stack frame)作用域。
命名空间默认使用dict数据结构，由多个键值对组成。
globals总是指向所在模块命名空间，而locals则指向当前作用域环境。
名字可随时重新关联另一个对象，而不在乎其类型是否相同。
## 检查保留字
```python
import keyword
keyword.kwlist
keyword.iskeyword("is")
```
## is和==
is语句判断两个名字是否引用同一对象，相等则比较值是否相等。
## 划线开头变量
模块成员以单下划线开头（_x），属私有成员，不会被 “import *” 语句导⼊。
• 类型成员以双下划线开头，但⽆结尾（__x），属私有成员，会被⾃动重命名。
• 以双下划线开头和结尾（__x__），通常是系统成员，避免使⽤。
• 交互模式（shell）下，单下划线（_）返回最后⼀个表达式结果。 
## 内存分配
基于性能考虑，像java，go这类语言，编译器会优先在栈（stack）上分配对象内存。但考虑到
闭包、接⼜、外部引⽤等因素，原本在栈上分配的对象可能会 “逃逸” 到堆（heap）。这势必会
延长对象⽣命周期，加⼤垃圾回收负担。所以，会有专门的逃逸分析（escape analysis），便于
优化代码和算法。
Python 虚拟机虽然也有执⾏栈的概念，但并不会在栈上为对象分配内存。从这点上来说，可以
认为所有原⽣对象（⾮ C、Cython 等扩展）都在 “堆” 上分配
```python
x = 1234
import sys
sys.getsizeof(x)  #python 3里int也是变长结构
```